function isTypedObject(object) {
  return isRecord(object) && typeof object._type == "string";
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function parseBlocks({
  context,
  blocks,
  options
}) {
  return Array.isArray(blocks) ? blocks.flatMap((block) => {
    const parsedBlock = parseBlock({
      context,
      block,
      options
    });
    return parsedBlock ? [parsedBlock] : [];
  }) : [];
}
function parseBlock({
  context,
  block,
  options
}) {
  return parseTextBlock({
    block,
    context,
    options
  }) ?? parseBlockObject({
    blockObject: block,
    context,
    options
  });
}
function parseBlockObject({
  blockObject,
  context,
  options
}) {
  if (!isTypedObject(blockObject))
    return;
  const schemaType = context.schema.blockObjects.find(({
    name
  }) => name === blockObject._type);
  if (schemaType)
    return parseObject({
      object: blockObject,
      context: {
        keyGenerator: context.keyGenerator,
        schemaType
      },
      options
    });
}
function isTextBlock(schema, block) {
  return parseTextBlock({
    block,
    context: {
      schema,
      keyGenerator: () => ""
    },
    options: {
      refreshKeys: !1
    }
  }) !== void 0;
}
function parseTextBlock({
  block,
  context,
  options
}) {
  if (!isTypedObject(block) || block._type !== context.schema.block.name)
    return;
  const _key = options.refreshKeys ? context.keyGenerator() : typeof block._key == "string" ? block._key : context.keyGenerator(), unparsedMarkDefs = Array.isArray(block.markDefs) ? block.markDefs : [], markDefKeyMap = /* @__PURE__ */ new Map(), markDefs = unparsedMarkDefs.flatMap((markDef) => {
    if (!isTypedObject(markDef))
      return [];
    const schemaType = context.schema.annotations.find(({
      name
    }) => name === markDef._type);
    if (!schemaType)
      return [];
    if (typeof markDef._key != "string")
      return [];
    const parsedAnnotation = parseObject({
      object: markDef,
      context: {
        schemaType,
        keyGenerator: context.keyGenerator
      },
      options
    });
    return parsedAnnotation ? (markDefKeyMap.set(markDef._key, parsedAnnotation._key), [parsedAnnotation]) : [];
  }), children = (Array.isArray(block.children) ? block.children : []).map((child) => parseSpan({
    span: child,
    context,
    markDefKeyMap,
    options
  }) ?? parseInlineObject({
    inlineObject: child,
    context,
    options
  })).filter((child) => child !== void 0), parsedBlock = {
    // Spread the entire block to allow custom properties on it
    ...block,
    _key,
    children: children.length > 0 ? children : [{
      _key: context.keyGenerator(),
      _type: context.schema.span.name,
      text: "",
      marks: []
    }],
    markDefs
  };
  if (typeof parsedBlock.style != "string" || !context.schema.styles.find((style) => style.value === block.style)) {
    const defaultStyle = context.schema.styles.at(0)?.value;
    defaultStyle !== void 0 ? parsedBlock.style = defaultStyle : delete parsedBlock.style;
  }
  return (typeof parsedBlock.listItem != "string" || !context.schema.lists.find((list) => list.value === block.listItem)) && delete parsedBlock.listItem, typeof parsedBlock.level != "number" && delete parsedBlock.level, parsedBlock;
}
function parseSpan({
  span,
  context,
  markDefKeyMap,
  options
}) {
  if (!isTypedObject(span) || span._type !== context.schema.span.name || span._type !== "span")
    return;
  const marks = (Array.isArray(span.marks) ? span.marks : []).flatMap((mark) => {
    if (typeof mark != "string")
      return [];
    const markDefKey = markDefKeyMap.get(mark);
    return markDefKey !== void 0 ? [markDefKey] : context.schema.decorators.some((decorator) => decorator.value === mark) ? [mark] : [];
  });
  return {
    // Spread the entire span to allow custom properties on it
    ...span,
    _type: "span",
    _key: options.refreshKeys ? context.keyGenerator() : typeof span._key == "string" ? span._key : context.keyGenerator(),
    text: typeof span.text == "string" ? span.text : "",
    marks
  };
}
function parseInlineObject({
  inlineObject,
  context,
  options
}) {
  if (!isTypedObject(inlineObject))
    return;
  const schemaType = context.schema.inlineObjects.find(({
    name
  }) => name === inlineObject._type);
  if (schemaType)
    return parseObject({
      object: inlineObject,
      context: {
        keyGenerator: context.keyGenerator,
        schemaType
      },
      options
    });
}
function parseAnnotation({
  annotation,
  context,
  options
}) {
  if (!isTypedObject(annotation))
    return;
  const schemaType = context.schema.annotations.find(({
    name
  }) => name === annotation._type);
  if (schemaType)
    return parseObject({
      object: annotation,
      context: {
        keyGenerator: context.keyGenerator,
        schemaType
      },
      options
    });
}
function parseObject({
  object,
  context,
  options
}) {
  const values = context.schemaType.fields.reduce((fieldValues, field) => {
    const fieldValue = object[field.name];
    return fieldValue !== void 0 && (fieldValues[field.name] = fieldValue), fieldValues;
  }, {});
  return {
    _type: context.schemaType.name,
    _key: options.refreshKeys ? context.keyGenerator() : typeof object._key == "string" ? object._key : context.keyGenerator(),
    ...values
  };
}
export {
  isTextBlock,
  isTypedObject,
  parseAnnotation,
  parseBlock,
  parseBlocks,
  parseInlineObject
};
//# sourceMappingURL=parse-blocks.js.map
